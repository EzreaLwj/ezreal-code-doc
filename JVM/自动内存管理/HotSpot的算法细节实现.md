# HotSpot 的算法细节实现



## 一、根节点枚举

所有收集器在**根节点枚举**这一步骤时都是**必须暂停用户线程**的，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的 Stop the world 的困扰。现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点的枚举始终还是必须在一个能保证一致性的快照中才得以进行。

由于目前主流的 Java 虚拟机都是**准确式垃圾收集**，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完**所有执行上下文（栈帧中的本地变量表）**和**全局的引用位置（例如常量或类静态属性）**，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在 HotSpot 的解决方案里，是使用一组称为 OopMap 的数据结构来达到这个目的的，一旦类加载动作完成，HotSpot 就会把对象内什么偏移量上是什么类型的数据计算出来。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等 GC Roots 开始查找。



## 二、安全点

在 OopMap 的协助下，HotSpot 可以快速准确地完成 GC Roots 枚举，但一个很现实的问题随之而来：**可能导致引用关系变化**，或者说导致 OopMap 内容变化的指令非常多，如果为每一条指令都生成对应的 OopMap，那将会需要大量的额外存储空间。

实际上 HotSpot 也的确没有为每条指令生成 OopMap，只是**在特定的位置记录这些信息**，这些位置就被称为**安全点**（Safepoint）。有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是**强制要求必须执行到达安全点后才能够暂停**。

**安全点的选取**基本上是以 **"是否具有让程序长时间执行的特征"** 为标准进行选定的，因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这样的原因而长时间执行，"长时间执行" 的最明显特征就是**指令序列的复用**，例如**方法调用**，**循环跳转**，**异常跳转**等都属于**指令序列复用**，所以只有具有这些功能的指令才会产生安全点。

对于安全点，另一个需要考虑的问题是，如何在垃圾收集发生时让所有线程都跑到最近的安全点。这里有两种方案可供选择：**抢先式中断**和**主动式中断**：

- **抢先式中断**：在垃圾收集时，系统会把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程的运行，让它一会再重新中断，直到跑到安全点上；
- **主动式中断**：当垃圾收集需要中断线程时，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起；



## 三、安全区域

**当用户线程处于 Sleep 状态或者 Blocked 状态，这时候线程无法响应虚拟机的中断请求**，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间，所以我们需要引入 **安全区域** 来解决。

安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化， 因此，**在这个区域中任意地方开始垃圾收集都是安全的**。当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举，如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域信号为止。



## 四、并发的可达性分析

从 GC Roots 再继续往下遍历对象图，这一步骤的停顿时间就必定会与 Java 堆容量直接成正比例关系了：堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长。要知道包含 "标记" 阶段是所有追踪式垃圾收集算法的共同特征，如果这个阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾收集器。



解决或者降低用户线程的停顿，就要保证在一个能保障一致性的快照上才能进行对象图的遍历，我们引入三色标记法来辅助推导：

- **白色**：**表示对象尚未被垃圾收集器访问过**，显然在可达性分	析刚刚开始的阶段，所有对象都是白色的，**若在分析结束的阶段，仍然是白色的对象，即代表不可达**。
- **黑色**：**表示对象以及被垃圾收集器访问过，且这个对象的所有引用都已经扫描过**。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象指向了黑色对象，无需重新扫描一遍。黑色对象不可能直接指向灰色对象。
- **灰色**：**表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过**。



在**用户线程与收集器并发工作**时，收集器在对象图上标记颜色，同时用户线程在修改引用关系 —— 即修改对象图的结构，这样会出现两种后果：

- 把原本消亡的对象错误标记为存活，这个影响不大，产生了一些浮动垃圾而已；
- 把原本存活的对象错误标记为死亡，这会导致程序发生错误；

下图演示了该致命错误是如何产生的：

![并发出现对象消失问题](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240204115051240.png)



当且仅当以下两个条件同时满足时，会产生对象消失问题，即原本是黑色的对象被误标为白色：

- 赋值器**插入**了一条或多条从**黑色对象到白色对象的新引用**；
- 赋值器**删除**了**全部从灰色对象到该白色对象的直接或间接引用**；

因此，我们要解决并发扫描时的对象消失问题，只需要破坏这两个条件的任意一个即可，由此产生了两种解决方案：**增量更新**和**原始快照**



增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简单理解为：黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象。

原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这可以简单理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。











