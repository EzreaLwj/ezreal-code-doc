# 垃圾回收与内存分配策略

Java 与 C++ 之间有一堵由**内存动态分配**和**垃圾收集技术**所围成的高墙，墙外面的人想进去，墙里面的人想进来。



## 一、背景

垃圾收集（Garbage Collection 简称 GC），需要考虑下面三个问题：

- 哪些内存需要回收；
- 什么时候回收；
- 如何回收；



在 Java 中，对于**程序计数器**、**虚拟机栈**、**本地方法栈**，都是随着线程开始而生，随线程的终结而亡，所以，这几个区域不需要过多考虑垃圾回收的问题。

而 **Java 堆**和**方法区**这两个区域则有着很大的不确定性：一个接口的多个实现类需要的内存可能不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有在运行阶段，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理。



## 二、对象存活判断

Java 堆中存放着几乎所有的对象实例，垃圾收集器在回收前，需要先判断这些对象中哪些对象还存活，哪些对象已经死去。



### 2.1 引用计数法

在对象中添加一个引用计数器，每当有一个地方引用它，计数器的值就加一，当引用失效后，计数器的值就减一，任何时刻计数器为零的对象就是不可能再被使用的。

但是单纯的引用计数算法无法解决对象的循环引用问题：

```java
public class ReferenceCountTest {

    public ReferenceCountTest instance;
    
    public static void main(String[] args) {
        ReferenceCountTest referenceCountTestA = new ReferenceCountTest();
        ReferenceCountTest referenceCountTestB = new ReferenceCountTest();
        
        referenceCountTestA.instance = referenceCountTestB;
        referenceCountTestB.instance = referenceCountTestA;
        
        System.gc();
    }
}
```

- 对象 A 引用着对象B，对象 B 又引用着对象 A，导致双方的引用计数不可能为 0，从而这两个对象永远无法被回收；



### 2.2 可达性分析算法

当前 Java 是通过**可达性分析算法**来判定对象是否存活的。这个算法的基本思路就是通过一系列称为 **GC Roots** 的**根对象**作为起始节点集，从这些节点开始，**根据引用关系向下搜索**，搜素过程所走过的路径称为 “引用链”。

如果某个对象到 GC Roots 间没有任何引用链相连，则证明此对象是不可能再被使用的。

![GC Root引用图](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240129174922717.png)

在 Java 技术体系中，固定可作为 **GC Roots** 的对象包括以下几种：

- 在**虚拟机栈中引用的对象**，譬如各个线程被调用的方法堆栈中使用到的**参数**、**局部变量**、**临时变量**等；
- 在**方法区中类静态属性引用的对象**，譬如 Java 类的引用类型静态变量；
- 在**方法区中常量引用的对象**，譬如字符串常量池中的引用；
- 在**本地方法栈**中 JNI（**Native** 方法）引用的对象；
- Java **虚拟机内部的引用**，如基本数据类型**对应的 Class 对象**，一些**常驻的异常对象**（**NullPointException**，**OutOfMemoryError**）等，还有**系统类加载器**；
- 所有被**同步锁**（Synchronized 关键字）持有的对象；
- **反映 Java 虚拟机内部情况**的 JM XBean、JVMT1 中注册的回调、本地代码缓存等；



## 三、引用类型

无论是通过**引用计数算法**判断对象的引用数量，还是通过**可达性分析算法**判断对象是否引用链可达，判定对象是否存活都和 “引用” 离不开关系。

在 JDK1.2 后，Java 对引用的概念进行了扩充，分为**强引用**，**软引用**，**弱引用**，**虚引用**，这4中引用强度依次逐渐降低。



### 3.1 强引用

强引用是最传统的引用，是指在程序代码之中普遍存在的引用赋值，即类似 `Object obj = new Object()`，无论在任何情况下，**只要强引用关系还在，那么垃圾收集器就永远不会回收掉这个对象**。



### 3.2 软引用

软引用是用来描述一些还有用，但非必要的对象。只被软引用关联的对象，**在系统将要发生内存溢出异常前**，会把这些对象列进回收范围之中**进行第二次垃圾回收**，如果这次回收还没有足够的内存，才会抛出内存溢出异常。可以使用 **SoftReference** 类来实现**软引用**。



### 3.3 弱引用

弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，**被弱引用关联的对象只能生成到下一次垃圾收集发生为止**。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉被弱引用关联的对象。可以使用 **WeakReference** 类来实现**弱引用**。



### 3.4 虚引用

虚引用也称为 “幽灵引用” 或者 “幻影引用”，它是最弱的一种引用关系。为一个对象**设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知**。可以使用 **PhantomReference** 类来实现**虚引用**。



## 四、对象的生存与死亡

即使在可达性分析算法中判定为不可达的对象，也不是 “非死不可”，这时候它们暂时处于缓刑阶段。

一个对象的真正死亡，至少要经历两次标记过程：

- 对象在可达性分析后没有与 GC Roots 对象相连接的引用链，则会被第一次标记；
- 如果有必要执行 finalize 方法，则会被第二次标记，放入到 F-Queue 队列中等待执行 finalize 方法



在对象被放入到 F-Queue 队列后，虚拟机会自动建立一个低调度优先级的 Finalizer 线程去执行它们的 finalize 方法，finalize 方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize 方法中拯救自己—— 只要重新与引用链上的任何一个对建立关联即可，那第二次标记时它将被移出即将回收的集合，如果对象这时候还没有逃脱，那它基本上就会被回收了。

> 任何对象的 finalize 方法只会被执行一次



## 五、方法区回收

《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK11 的 ZGC 收集器）



方法区的垃圾收集主要回收两部分内容：**废弃的常量**和**不再使用的类型**。

### 5.1 废弃的常量

假如一个字符串 “Java” 进入到常量池中，但系统却没有一个字符串对象的值是 “Java”。如果在这时发生垃圾回收，而且垃圾收集器判断有必要的话，这个 "java" 常量就会被清理出常量池，常量池中其他类（接口）、方法、字段的符号引用也与此类似。



### 5.2 不再使用的类型

判断为不再使用的类型需要同时满足以下三个条件：

- **该类所有的实例都已经被回收**，也就是 Java 堆中不存在该类及其任何派生子类的实例；
- **加载该类的类加载器已经被回收**，这个条件除非是经过精心设计的可替换的场景，如 OSGi、JSP 的重加载等，否则通常很难达成的；
- **该类对应的 java.lang.Class 对象没有在任何地方被引用**，无法再任何地方通过反射访问到该类的方法；



## 六、垃圾收集算法



### 6.1 分代收集理论

当前商业虚拟机的垃圾收集器，大多数都遵循 "分代收集" 的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则：

- **弱分代假说**：绝大多数对象都是朝生夕死的；
- **强分代假说**：熬过越多次垃圾收集过程的对象就越难以消亡；

这两个假说共同奠定了常用垃圾收集器的一致的设计原则：收集器应该将 Java 堆划分出不同的区域，然后**将回收对象依据其年龄分配到不同的区域之中存储**。如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么就把它们集中放到一起，每次回收时**只关注如何保留少量存活而不是去标记那些大量将要被回收的对象**；如果剩下的都是难以消亡的对象，那么就把它们放到一块，虚拟机便可以以较低的频率来回收这个区域，这就**兼顾了垃圾收集的时间开销和内存的空间有效利用**。

在 Java 堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了 "Minor GC"，"Major GC"，"Full GC" 这样回收类型的划分，也饿才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法。

- **新生代收集**（Minor GC / Young GC）：指目标只是新生代的垃圾收集；
- **老年代收集**（Major GC / Old GC）：指目标只是老年代的垃圾收集，目前只有 CMS 收集器会有单独收集老年代的行为；
- **混合收集**（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集，目前只有 G1 收集器会有这种行为；
- **整堆收集**（Full GC）：收集整个 Java 堆和方法区的垃圾收集；

**跨代引用**

新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的 GC Roots 之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，这会给内存回收带来很大的性能负担。

- **跨代引用假说**：跨代引用相对于同代引用来说仅占极少数；

依据这条假说，我们就不应该为了少数跨代引用去扫描整个老年代，只需要在新生代上建立一个全局的数据结构，这个结构把老年代划分为若干小块，标识出老年代的哪一块内存存在跨代引用。此后发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描。



### 6.2 标记-清除算法

标记-清除算法分成 "标记" 和 "清除" 两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。

这个算法有两个缺点：

- 执行效率不稳定；
- 内存空间碎片化，导致分配大对象时内存不足，不得不再次进行一次垃圾收集动作；

![标记清除算法](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240130213935743.png)



### 6.3 标记-复制算法

标记-复制算法常被简称为**复制算法**。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还**存活着的对象复制到另外一块上面**，然后再把已使用过的内存空间一次清理掉。

![标记复制算法](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240130214350859.png)

优点：

- **不存在内存碎片**；
- 效率高，算法复制的就是占少数的存活对象，只要移动堆顶指针，**顺序分配**；

缺点：

- 如果存活的对象多，那么将产生大量内存间复制的开销；
- **可用内存缩小成为原来的一半**，空间浪费未免太多了；



现在的 Java 虚拟机大多都优先采用了这种标记-复制算法去回收新生代，新生代中的对象有 98% 熬不过第一轮收集，针对朝生夕灭的特点， Andrew Appel 提出了 "Appel 式回收"，一种更优化的半区复制分代策略。HotSpot 虚拟机的 **Serial**、**ParNew** 等新生代收集器均采用了这种策略来设计新生代的内存布局。

具体做法为：

1. 把**新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间**，每次分配内存只使用 Eden 和其中一块 Survivor；
2. 发生垃圾收集时，将 **Eden** 和 **Survivor** 中仍然存活的对象一次性复制到**另外一块 Survivor 空间**上；
3. 然后**直接清理掉 Eden 和已用过的那块 Survivor 空间**；

HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1，也即每次新生代中可用内存空间为整个新生代容量的 90%，只有一个 Survivor 空间，即 10% 的新生代是会被 "浪费" 的。

**当 Survivor 空间不足以容纳一次 Minor GC 之后存活的对象时**，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保，这些对象便将通过分配担保机制直接进入老年代。



### 6.4 标记-整理算法

**标记-复制算法在对象存活率较高时要进行较多的复制操作，效率会降低**。更关键的是，如果不想浪费 50% 的空间，就需要有额外的空间进行担保分配，以应对被使用的内存中所有对象都 100% 存活的极端情况，所有老年代不能直接使用 **标记-复制** 算法。

![标记整理算法](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240130213715099.png)



针对老年代对象的存亡特征，1974 年 Edward Lueders 提出了另外一种有针对性的 "标记-整理" 算法，其标记过程跟 "标记-清除" 算法一样，但后续步骤不是直接对可回收对象进行清理，具体做法为：

- 让所有**存活的对象都向内存空间一端移动**；
- 然后**直接清理掉边界以外的内存**；



如果移动存活对象，尤其是在**老年代这种每次回收都有大量存活对象的区域**，**移动存活对象并更新所有引用这些对象**的地方将会是一种极为负重的操作，而且这种**对象移动操作必须全程暂停用户应用程序才能进行**，简称为 "stop the world"。

但如果跟标记-清除算法那样不考虑移动和整理存活对象的话，弥散与堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。

基于以上两点，是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内次分配时会更复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。HotSpot 虚拟机里面关注吞吐量的 Parallel Scavenge 收集器是基于标记-整理算法的，而关注延迟的 CMS 收集器则是基于标记-清除算法的。



## 七、经典垃圾收集器
如果说**收集算法是内存回收的方法论**，那**垃圾收集器就是内存回收的实践者**。接下来将逐一介绍这些收集器的**目标**、**特性**、**原理**和**使用场景**，并重点分析 **CMS** 和 **G1** 这两款相对复杂而又广泛使用的收集器。

![垃圾收集器类型](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240130231313916.png)



### 7.1 Serial 收集器

**Serial 收集器**是最基础、历史最悠久的收集器。这个收集器是一个**新生代单线程工作的收集器**，单线程不仅说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。

![Serial垃圾收集器](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240130234635188.png)

- 新生代采取标记-复制算法，老年代采取标记-整理算法；
- Serial 收集器对于运行在客户端模式下的虚拟机是一个很好的选择；



### 7.2 ParNew 收集器

**ParNew 收集器实质上是 Serial 收集器的多线程并行版本**，处理同时使用多条线程进行垃圾收集之外，其余本地行为包括 Serial 收集器可用的所有控制参数、收集算法、 Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一致。

![ParNew垃圾收集器](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240131000832577.png)

- ParNew 收集器除了支持多线程收集之外，其他与 Serial 收集器相比并没有太多的创新之处；
- ParNew 在单核心处理器的环境中绝对不会有比 Serial 收集器更好的效果；



### 7.3 Parallel Scavenge 收集器

**Parallel Scavenge 收集器也是一款新生代收集器**，它同样是**基于标记-复制算法实现的收集器**，也是能够**并行收集**的多线程收集器。

Parallel Scavenge 收集器的特点是它的关注点与其他的收集器不同，**CMS** 等收集器的关注点是**尽可能地缩短垃圾收集时用户线程的等待时间**，而 **Parallel Scavenge** 收集器的目标**则是达到一个可控制的吞吐量**（Throughput），即：

$$\begin{align}吞吐量=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}\end{align}$$

> 停顿时间越短越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互分析的任务。



Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量：

- -XX:MaxGCPauseMillis：控制最大垃圾收集停顿时间；
- -XX:GCTimeRatio：直接设置吞吐量的大小



-XX:MaxGCPauseMillis 参数允许的值是一个大于 0 的毫秒数，**收集器将尽力保证内存回收花费的时间不超过用户设定值**，**垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的**，系统把新生代调小一点，收集 300MB 新生代肯定比收集 500MB 快，但这也直接导致了垃圾收集发生得更加频繁，原来 10 秒收集一次，每次停顿 100 毫秒，现在变成 5 秒收集一次，每次停顿 70 毫秒。停顿时间下降，但吞吐量也降下来了。



### 7.4 Serial Old 收集器

**Serial Old 是 Serial 收集器的老年代版本**，它同样是一个**单线程**收集器，使用**标记-整理算法**，这个收集器的主要意义也是供客户端模式下的 HotSpot 虚拟机使用的。

![Serial Old垃圾收集器](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240130234635188.png)



### 7.5 Parallel Old 收集器

Parallel Old 是 Parallel Scavenge 收集器的老年代版本，支持**多线程并发收集**，基于**标记-整理算法**实现。

![Parallel Old收集器](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240131113924689.png)



### 7.6 CMS 收集器

CMS （Concurrent Mark Sweep）收集器是一种以**获取最短回收停顿时间**为目标的收集器。目前很大一部分的 Java 应用集中在互联网网站或者基于浏览器的 B/S 系统的服务端上，这类应用通常都会较为关注服务的响应速度，给用户带来良好的交互体验。CMS 收集器就非常符合这类应用的需求。



从名字 Mark Sweep 就可以看出 **CMS 收集器是基于标记-清除算法实现的**，它的收集过程分为 **4 个步骤**：

- **初始标记**（CMS initial mark）
- **并发标记**（CMS concurrent mark）
- **重新标记**（CMS remark）
- **并发清除**（CMS concurrent sweep）



**初始标记**只是标记一下 GC Roots 能**直接关联**到的对象，速度很快；**并发标记**阶段就是**从 GC Roots 的直接关联对象开始**遍历整个对象图的过程，这个过程**耗时较长**但**不需要暂停用户线程**，可以与垃圾收集线程一同并发运行；而**重新标记阶段**则是为了修正并发标记期间，因用户线程继续运作而导致**标记产生变动的那一部分对象的标记记录**，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记时间短；最后是**并发清除阶段**，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

> 初始标记和重新标记都是需要 Stop The World



由于在整个过程中**耗时最长**的**并发标记**和**并发清除阶段**中，**垃圾收集器线程都可以与用户线程一起工作**，所以从总体上来说，CMS 收集器的内存回收过程与用户线程一起并发执行的。

![CMS垃圾收集器](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240131135403154.png)

CMS 是一款优秀的收集器，并发收集，低延迟。



但 CMS 并非没有缺点：

- **CMS 处理器对处理器资源非常敏感**，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，降低总吞吐量。CMS 的默认启动的回收线程是 $\frac{处理器核心线程数 + 3}{4}$
- **CMS 收集器无法处理浮动垃圾**，有可能出现 "Con-current Mode Failure" 失败进而导致另外一次 "Stop The World" 的 Full GC 的产生。在 CMS 的**并发标记**和**并发清理**阶段，用户线程还是继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现标记过程结束后，CMS 无法再当次收集中处理掉它们，只好等到下次垃圾收集再清理，这些垃圾就被称为 **"浮动垃圾"**。
- **产生大量的内存碎片**，CMS 是基于标记-清除算法，就可能想到这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是找不到足够大的连续空间来分配当前对象，而不得不提前触发一次 Full GC 的情况；



### 7.7 Garbage First 收集器

Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器**面向局部收集**的设计思路和**基于 Region 的内存布局形式**。

在 G1 收集器出现之前的所有其他收集器，包括 CMS 在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么是整个老年代（Major GC），再要么就是整个 Java 堆（Full GC）。而 G1 跳出这个牢笼，**它可以面向堆内存任何部分来组成回收集（Collection Set，简称为 CSet）进行回收**，**衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收的收益最大，这就是 G1 收集器的 Mixed GC 模式**。



G1开创的**基于 Region 的堆内存布局**是它能够实现这个目标的关键，虽然 G1 也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：**G1 不再坚持固定大小以及固定数量的分代区域划分，而是把 Java 堆划分为多个大小相等的独立区域（Region）**，每一个 Region 根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。收集器能够对扮演不同角色的 Region 采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间，熬过多次收集的旧对象都能获取很好的收集效果。



Region 中还有一类特殊的 **Humongous 区域**，**专门用来存储大对象**。**G1 认为只要大小超过了一个 Region 容量一半的对象即可判定为大对象**。每一个 Region 的大小可以通过参数 `-XX: G1HeapRegionSize` 设定，取值范围为 `1MB~32MB`，且应为2的N次幂。而对于那些超过了整个 Region 容量的超级大对象，将会被存放在 N 个连续的 Humongous Region 之中，G1 的大多数行为都把 Humongous Region 作为老年代的一部分来进行看待。

![G1垃圾回收器](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240131204911788.png)

G1 收集器的运作过程可划分为以下**四个步骤**：

- **初始标记**（Initial Marking）：仅仅只是**标记一下 GC Roots 能直接关联到的对象**，并且修改 TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配对象。这个阶段需要**停顿线程**，但耗时很短，而且是借用进行 Minor GC 的时候同步完成的；
- **并发标记**（Concurrent Marking）：**从 GC Root 开始对堆中对象进行可达性分析**，递归扫描整个堆里的对象图，**找出要回收的对象**，这阶段耗时较长，但**可与用户程序并发执行**。当对象图扫描完成以后，还要重新处理 SATB 记录下的在并发时有引用变动的对象；
- **最终标记**（Final Marking）：对**用户线程做另一个短暂的暂停**，用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录；
- **筛选回收**（Live Data Counting and Evacuation）：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，**根据用户所期望的停顿时间来制定回收计划**，可以**自由选择任意多个 Region 构成回收集**，然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间，这里的操作设计存活对象的移动，是必须**暂停用户线程**，由多条收集器线程并行完成的。


## 八、实战：内存分配与回收策略

对象内存分配，应该都是在堆上分配。在经典分代的设计下，新生对象通常会分配在新生代中，少数情况下也可能会直接分配在老年代。下面使用 HotSpot 虚拟机来验证内存分配的规则。



### 8.1 对象优先在 Eden 分配

大多数情况下，对象在新生代 Eden 区分配，当 **Eden 区没有足够空间**进行分配时，虚拟机将发起一次 **Minor GC**。

```java
/** 
 * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
 * @author Ezreal
 * @Date 2024/2/4
 */
public class EdenAllocation {
    private static final int _1MB = 1024 * 1024;
    public static void main(String[] args) {

        byte[] allocation1, allocation2, allocation3, allocation4;

        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[2 * _1MB];
        allocation4 = new byte[4 * _1MB]; // 产生一次 Minor GC
    }
}
```



在代码中，尝试分配三个 2MB 大小和一个 4MB 大小的对象，在运行时通过 -Xms20M、-Xmx20M、-Xmn10M 这三个参数限制了 Java 堆大小为 20MB。

- **-Xms20M**：设置初始堆内存大小为 20MB，这是虚拟机**启动时分配**的初始内存大小；
- **-Xmx20M**：设置最大堆内存大小为 20MB，这是虚拟机**可以使用**的最大内存大小；
- **-Xmn20M**：设置年轻代的大小为 10MB，年轻代是堆内存的一部分，用于分配新创建的对象；



```powershell
Heap
 PSYoungGen      total 9216K, used 8192K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 100% used [0x00000000ff600000,0x00000000ffe00000,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
 ParOldGen       total 10240K, used 4096K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 40% used [0x00000000fec00000,0x00000000ff000010,0x00000000ff600000)
 Metaspace       used 3304K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 359K, capacity 388K, committed 512K, reserved 1048576K
```

- -XX:SurvivorRatio=8：决定了新生代中 Eden 区与一个 Survivor 区的空间比例是 8:1，从上述日志中可以看出，eden space 8192K，from space 1024K，to space 1024K，新生代总可用空间为 9216 K（Eden + 一个 Survivor 区）；
- 当开始分配 4 MB时，Eden 已经占用了 6 MB，剩余的空间不足以分配 allocation4 所需的 4 MB，所以会进行一次 Minor GC。但垃圾收集期间虚拟机又发现已有的两个 2MB 大小的对象无法放入 Survivor 空间（Survivor 区只有 1MB 大小），所以只好通过**分配担保机制**提前转移到老年代去；



### 8.2 大对象直接进入老年代

大对象就是指需要大量连续内存空间的 Java 对象，最典型的大对象便是那种很长的字符串，或者数量很庞大的数组。

比遇到一个大对象更坏的消息就是遇到一群朝生夕灭的短命大对象。在分配内存时，它容易导致内存明明还有不少空间就提前触发垃圾收集，而当复制对象时，大对象就意味着高额的内存复制开销。

HotSpot 虚拟机提供了 **-XX:PretenureSizeThreshold** 参数，指定大于该设置值的对象直接在老年代分配，**避免对象在 Eden 和 Survivor 区之间来回复制**。



```java
/**
 * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:PretenureSizeThreshold=1024
 * @param args
 * @throws InterruptedException
 */
public static void main(String[] args) throws InterruptedException {
    byte[] allocation;
    allocation = new byte[4 * _1MB];
}
```



### 8.3 长期存活的对象将进入老年代

HotSpot 虚拟机中多数收集器都采用了**分代收集来管理堆内存**，那内存回收时就必须能决策哪些存活对象应当存放在新生代，哪些存活对象存放在老年代。为了做到这点，虚拟机给每个对象定义了一个对象年龄计数器，存储在对象头中。

对象通常在 Eden 中诞生，如果**经过一次 Minor GC 后依然存活**，**并且能被 Survivor 容纳的话**，该对象会被移动到 Survivor 空间中，并且设置对象年龄为 1岁。对象在 Survivor 区中每熬过一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15），就会被晋升到老年代中。**对象晋升老年代的年龄阈值**，可以通过参数 **-XX:MaxTenuringThresold** 设置。

```java
/**
 * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution
 * @param args
 */
public static void main(String[] args) {
    byte[] allocation1, allocation2, allocation3;

    allocation1 = new byte[_1MB / 4]; // 什么时候进入老年代由-XX:MaxTenuringThreshold决定
    allocation2 = new byte[4 * _1MB];
    allocation3 = new byte[4 * _1MB];
    allocation3 = null;
    allocation3 = new byte[4 * _1MB];
}
```

- 当 -XX:MaxTenuringThresold = 1时，allocation1 对象在第二次 GC 时进入老年代；
- 当 -XX:MaxTenuringThresold = 15时，allocation1 依然留在新生代 Surivior 空间；



### 8.4 动态对象年龄判定

为了能更好适应不同程序的内存状况，HotSpot 虚拟机并不是永远要求对象的年龄必须达到 **-XX:MaxTenuringThresold** 才能晋升老年代，如果在 **Surivior 空间中相同年龄所有对象大小的总和大于 Surivior 空间的一半**，**年龄大于或等于该年龄的对象**就可以直接**进入老年代**，无须等到要求的年龄。

```java
/**
 * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15 -XX:+PrintTenuringDistribution 
 * @param args
 */
public static void main(String[] args) {
    byte[] allocation1, allocation2, allocation3, allocation4;

    allocation1 = new byte[_1MB / 4]; // allocation1 + allocation2 大于Surivior空间的一半
    allocation2 = new byte[_1MB / 4];
    allocation3 = new byte[2 * _1MB];
    allocation4 = new byte[4 * _1MB];
    allocation4 = null;
    allocation4 = new byte[4 * _1MB];
}
```



### 8.5 空间分配担保

在发生 Minor GC 之前，虚拟机必须先**检查老年代最大可用的连续空间是否大于新生代所有对象总空间**，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 -**XX:HanldePromotionFailure** 参数的设置值是否允许担保失败：如果允许，那会继续**检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小**，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 `-XX:HandlePromotionFailure` 设置不允许冒险，那这时就要改为进行一次 Full GC。

这里的冒险是指：新生代使用复制收集算法，但为了内存利用率，只使用一个 Surivior 空间作为轮换备份，因此当出现大量对象在 Minor GC 后仍然存活的情况 —— 最极端的情况是内存回收后新生代中所有对象都存活，需要老年代进行担保分配，把 Survivor 无法容纳的对象直接送入老年代。老年代要进行担保，前提是老年代本身还有容纳这些对象的剩余空间，但一共有多少对象会在这次回收中活下来在实际完成内存回收之前是无法明确知道的，所以只能取之前每一次回收晋升到老年代对象容量的平均大小作为经验值，与老年代的剩余空间进行比较，决定是否进行 Full GC 来让老年代腾出更多空间。

取历史平均值来比较其实仍然是一种赌概率的解决办法，也就是说假如某次 Minor GC 存活后的对象突增，远远高于历史平均值的话，依然会导致担保失败。如果出现了担保失败，那就只好老老实实地重新发起一次 Full GC，这样停顿时间就很长了。

在 JDK6 Update24 之后，`-XX:HandlePromotionFailure` 参数不再会影响到虚拟机的空间分配担保策略，虽然源码中还定义了 `-XX:HandlePromotionFailure` 参数，但是在实际虚拟机中已经不会再使用它。JDK6 Update24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则进行 Full GC。

