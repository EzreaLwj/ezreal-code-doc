# 垃圾回收与内存分配策略

Java 与 C++ 之间有一堵由**内存动态分配**和**垃圾收集技术**所围成的高墙，墙外面的人想进去，墙里面的人想进来。



## 一、背景

垃圾收集（Garbage Collection 简称 GC），需要考虑下面三个问题：

- 哪些内存需要回收；
- 什么时候回收；
- 如何回收；



在 Java 中，对于**程序计数器**、**虚拟机栈**、**本地方法栈**，都是随着线程开始而生，随线程的终结而亡，所以，这几个区域不需要过多考虑垃圾回收的问题。

而 **Java 堆**和**方法区**这两个区域则有着很大的不确定性：一个接口的多个实现类需要的内存可能不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有在运行阶段，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理。



## 二、对象存活判断

Java 堆中存放着几乎所有的对象实例，垃圾收集器在回收前，需要先判断这些对象中哪些对象还存活，哪些对象已经死去。



### 2.1 引用计数法

在对象中添加一个引用计数器，每当有一个地方引用它，计数器的值就加一，当引用失效后，计数器的值就减一，任何时刻计数器为零的对象就是不可能再被使用的。

但是单纯的引用计数算法无法解决对象的循环引用问题：

```java
public class ReferenceCountTest {

    public ReferenceCountTest instance;
    
    public static void main(String[] args) {
        ReferenceCountTest referenceCountTestA = new ReferenceCountTest();
        ReferenceCountTest referenceCountTestB = new ReferenceCountTest();
        
        referenceCountTestA.instance = referenceCountTestB;
        referenceCountTestB.instance = referenceCountTestA;
        
        System.gc();
    }
}
```

- 对象 A 引用着对象B，对象 B 又引用着对象 A，导致双方的引用计数不可能为 0，从而这两个对象永远无法被回收；



### 2.2 可达性分析算法

当前 Java 是通过**可达性分析算法**来判定对象是否存活的。这个算法的基本思路就是通过一系列称为 **GC Roots** 的**根对象**作为起始节点集，从这些节点开始，**根据引用关系向下搜索**，搜素过程所走过的路径称为 “引用链”。

如果某个对象到 GC Roots 间没有任何引用链相连，则证明此对象是不可能再被使用的。

![GC Root引用图](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240129174922717.png)

在 Java 技术体系中，固定可作为 **GC Roots** 的对象包括以下几种：

- 在**虚拟机栈中引用的对象**，譬如各个线程被调用的方法堆栈中使用到的**参数**、**局部变量**、**临时变量**等；
- 在**方法区中类静态属性引用的对象**，譬如 Java 类的引用类型静态变量；
- 在**方法区中常量引用的对象**，譬如字符串常量池中的引用；
- 在**本地方法栈**中 JNI（**Native** 方法）引用的对象；
- Java **虚拟机内部的引用**，如基本数据类型**对应的 Class 对象**，一些**常驻的异常对象**（**NullPointException**，**OutOfMemoryError**）等，还有**系统类加载器**；
- 所有被**同步锁**（Synchronized 关键字）持有的对象；
- **反映 Java 虚拟机内部情况**的 JM XBean、JVMT1 中注册的回调、本地代码缓存等；



## 三、引用类型

无论是通过**引用计数算法**判断对象的引用数量，还是通过**可达性分析算法**判断对象是否引用链可达，判定对象是否存活都和 “引用” 离不开关系。

在 JDK1.2 后，Java 对引用的概念进行了扩充，分为**强引用**，**软引用**，**弱引用**，**虚引用**，这4中引用强度依次逐渐降低。



### 3.1 强引用

强引用是最传统的引用，是指在程序代码之中普遍存在的引用赋值，即类似 `Object obj = new Object()`，无论在任何情况下，**只要强引用关系还在，那么垃圾收集器就永远不会回收掉这个对象**。



### 3.2 软引用

软引用是用来描述一些还有用，但非必要的对象。只被软引用关联的对象，**在系统将要发生内存溢出异常前**，会把这些对象列进回收范围之中**进行第二次垃圾回收**，如果这次回收还没有足够的内存，才会抛出内存溢出异常。可以使用 **SoftReference** 类来实现**软引用**。



### 3.3 弱引用

弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，**被弱引用关联的对象只能生成到下一次垃圾收集发生为止**。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉被弱引用关联的对象。可以使用 **WeakReference** 类来实现**弱引用**。



### 3.4 虚引用

虚引用也称为 “幽灵引用” 或者 “幻影引用”，它是最弱的一种引用关系。为一个对象**设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知**。可以使用 **PhantomReference** 类来实现**虚引用**。



## 四、对象的生存与死亡

即使在可达性分析算法中判定为不可达的对象，也不是 “非死不可”，这时候它们暂时处于缓刑阶段。

一个对象的真正死亡，至少要经历两次标记过程：

- 对象在可达性分析后没有与 GC Roots 对象相连接的引用链，则会被第一次标记；
- 如果有必要执行 finalize 方法，则会被第二次标记，放入到 F-Queue 队列中等待执行 finalize 方法



在对象被放入到 F-Queue 队列后，虚拟机会自动建立一个低调度优先级的 Finalizer 线程去执行它们的 finalize 方法，finalize 方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize 方法中拯救自己—— 只要重新与引用链上的任何一个对建立关联即可，那第二次标记时它将被移出即将回收的集合，如果对象这时候还没有逃脱，那它基本上就会被回收了。

> 任何对象的 finalize 方法只会被执行一次



## 五、方法区回收

《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK11 的 ZGC 收集器）



方法区的垃圾收集主要回收两部分内容：**废弃的常量**和**不再使用的类型**。

### 5.1 废弃的常量

假如一个字符串 “Java” 进入到常量池中，但系统却没有一个字符串对象的值是 “Java”。如果在这时发生垃圾回收，而且垃圾收集器判断有必要的话，这个 "java" 常量就会被清理出常量池，常量池中其他类（接口）、方法、字段的符号引用也与此类似。



### 5.2 不再使用的类型

判断为不再使用的类型需要同时满足以下三个条件：

- **该类所有的实例都已经被回收**，也就是 Java 堆中不存在该类及其任何派生子类的实例；
- **加载该类的类加载器已经被回收**，这个条件除非是经过精心设计的可替换的场景，如 OSGi、JSP 的重加载等，否则通常很难达成的；
- **该类对应的 java.lang.Class 对象没有在任何地方被引用**，无法再任何地方通过反射访问到该类的方法；



## 六、垃圾收集算法



### 6.1 分代收集理论

当前商业虚拟机的垃圾收集器，大多数都遵循 "分代收集" 的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则：

- **弱分代假说**：绝大多数对象都是朝生夕死的；
- **强分代假说**：熬过越多次垃圾收集过程的对象就越难以消亡；

这两个假说共同奠定了常用垃圾收集器的一致的设计原则：收集器应该将 Java 堆划分出不同的区域，然后**将回收对象依据其年龄分配到不同的区域之中存储**。如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么就把它们集中放到一起，每次回收时**只关注如何保留少量存活而不是去标记那些大量将要被回收的对象**；如果剩下的都是难以消亡的对象，那么就把它们放到一块，虚拟机便可以以较低的频率来回收这个区域，这就**兼顾了垃圾收集的时间开销和内存的空间有效利用**。

在 Java 堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了 "Minor GC"，"Major GC"，"Full GC" 这样回收类型的划分，也饿才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法。

- **新生代收集**（Minor GC / Young GC）：指目标只是新生代的垃圾收集；
- **老年代收集**（Major GC / Old GC）：指目标只是老年代的垃圾收集，目前只有 CMS 收集器会有单独收集老年代的行为；
- **混合收集**（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集，目前只有 G1 收集器会有这种行为；
- **整堆收集**（Full GC）：收集整个 Java 堆和方法区的垃圾收集；

**跨代引用**

新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的 GC Roots 之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，这会给内存回收带来很大的性能负担。

- **跨代引用假说**：跨代引用相对于同代引用来说仅占极少数；

依据这条假说，我们就不应该为了少数跨代引用去扫描整个老年代，只需要在新生代上建立一个全局的数据结构，这个结构把老年代划分为若干小块，标识出老年代的哪一块内存存在跨代引用。此后发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描。



### 6.2 标记-清除算法

标记-清除算法分成 "标记" 和 "清除" 两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。

这个算法有两个缺点：

- 执行效率不稳定；
- 内存空间碎片化，导致分配大对象时内存不足，不得不再次进行一次垃圾收集动作；

![标记清除算法](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240130213935743.png)



### 6.3 标记-复制算法

标记-复制算法常被简称为**复制算法**。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还**存活着的对象复制到另外一块上面**，然后再把已使用过的内存空间一次清理掉。

![标记复制算法](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240130214350859.png)

优点：

- **不存在内存碎片**；
- 效率高，算法复制的就是占少数的存活对象，只要移动堆顶指针，**顺序分配**；

缺点：

- 如果存活的对象多，那么将产生大量内存间复制的开销；
- **可用内存缩小成为原来的一半**，空间浪费未免太多了；



现在的 Java 虚拟机大多都优先采用了这种标记-复制算法去回收新生代，新生代中的对象有 98% 熬不过第一轮收集，针对朝生夕灭的特点， Andrew Appel 提出了 "Appel 式回收"，一种更优化的半区复制分代策略。HotSpot 虚拟机的 **Serial**、**ParNew** 等新生代收集器均采用了这种策略来设计新生代的内存布局。

具体做法为：

1. 把**新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间**，每次分配内存只使用 Eden 和其中一块 Survivor；
2. 发生垃圾收集时，将 **Eden** 和 **Survivor** 中仍然存活的对象一次性复制到**另外一块 Survivor 空间**上；
3. 然后**直接清理掉 Eden 和已用过的那块 Survivor 空间**；

HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1，也即每次新生代中可用内存空间为整个新生代容量的 90%，只有一个 Survivor 空间，即 10% 的新生代是会被 "浪费" 的。

**当 Survivor 空间不足以容纳一次 Minor GC 之后存活的对象时**，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保，这些对象便将通过分配担保机制直接进入老年代。



### 6.4 标记-整理算法

**标记-复制算法在对象存活率较高时要进行较多的复制操作，效率会降低**。更关键的是，如果不想浪费 50% 的空间，就需要有额外的空间进行担保分配，以应对被使用的内存中所有对象都 100% 存活的极端情况，所有老年代不能直接使用 **标记-复制** 算法。

![标记整理算法](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240130213715099.png)



针对老年代对象的存亡特征，1974 年 Edward Lueders 提出了另外一种有针对性的 "标记-整理" 算法，其标记过程跟 "标记-清除" 算法一样，但后续步骤不是直接对可回收对象进行清理，具体做法为：

- 让所有**存活的对象都向内存空间一端移动**；
- 然后**直接清理掉边界以外的内存**；



如果移动存活对象，尤其是在**老年代这种每次回收都有大量存活对象的区域**，**移动存活对象并更新所有引用这些对象**的地方将会是一种极为负重的操作，而且这种**对象移动操作必须全程暂停用户应用程序才能进行**，简称为 "stop the world"。

但如果跟标记-清除算法那样不考虑移动和整理存活对象的话，弥散与堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。

基于以上两点，是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内次分配时会更复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。HotSpot 虚拟机里面关注吞吐量的 Parallel Scavenge 收集器是基于标记-整理算法的，而关注延迟的 CMS 收集器则是基于标记-清除算法的。



## 七、经典垃圾收集器

