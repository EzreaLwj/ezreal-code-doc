# 线程安全与锁优化



## 一、背景

面向对象的编程思想极大地提升了现代软件开发的效率和软件可以达到的规模，但是现实世界与计算机世界之间不可避免地存在一些差异。例如，人们很难想象现实中的对象在一项工作进行期间，**会被不停地中断和切换**，对象的属性（数据）可能会**在中断期间被修改和变脏**，而这些事件在计算机世界中是再普通不过的事情。有时候，良好的设计原则不得不向现实做出一些妥协，我们必须保证程序在计算机中正确无误地运行，然后再考虑如何将代码组织得更好，让程序运行得更快。对于本章的主题 "高效并发" 来说，首先需要保证并发的正确性，然后在此基础上来实现高效。本章就先从如何保证并发的正确性及如何实现线程安全说起。



## 二、线程安全

**线程安全定义**：当多个线程同时访问一个对象时，如果**不用考虑**这些线程在**运行时环境下的调度和交替执行**，也**不需要进行额外的同步**，或者在**调用方进行任何其他的协调操作**，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。



### 2.1 Java语言中的线程安全

接下来讨论，在 Java 语言中线程安全是如何体现的？有哪些操作是线程安全的？我们这里讨论的线程安全，将以多个线程之间存在共享数据为前提。



#### 2.1.1 不可变

在 Java 里面**不可变对象一定是线程安全的**，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。

Java 语言中，如果多线程**共享的数据**是一个**基本数据类型**，那么只要在定义时使用 **final** 关键字修饰它就可以**保证它是不可变**的。如果是一个对象，由于 Java 语言目前暂时还没有提供值类型的支持，那就需要**对象自行保证其行为不会对其状态产生任何影响才行**。例如：java.lang.String 类的对象实例，它是一个典型的不可变对象，用户调用它的 `substring()`，`replace()`，`concat()` 这些方法都不会影响它原来的值，**只会返回一个新构造的字符串对象**。

保证对象行为不影响自己状态的途径有很多种，最简单的一种就是**把对象里面带有状态的变量都声明为 final**，这样在构造函数结束之后，它就是不可变的。

```java
/**
 * The value of the {@code Integer}.
 *
 * @serial
 */
private final int value;

/**
 * Constructs a newly allocated {@code Integer} object that
 * represents the specified {@code int} value.
 *
 * @param   value   the value to be represented by the
 *                  {@code Integer} object.
 */
public Integer(int value) {
    this.value = value;
}
```

- Integer 类中 value 定义为 final 来保障状态不变；



#### 2.1.2 绝对线程安全

绝对的线程安全能够完全满足 Brian Goetz 给出的线程安全的定义，这个定义其实是很严格的。一个类要达到 "不管运行时环境如何，调用者都不需要任何额外的同步措施" 可能需要付出非常高昂的代价。



比如说 `java.util.Vector` 是一个线程安全的容器。因为它的 `add`、`get`、`size` 方法都被 synchronized 修饰，调用它的时候就永远都不再需要同步手段了。

```java
// 添加
public synchronized void addElement(E obj) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = obj;
}

// 移除
public synchronized boolean removeElement(Object obj) {
    modCount++;
    int i = indexOf(obj);
    if (i >= 0) {
        removeElementAt(i);
        return true;
    }
    return false;
}
```



#### 2.1.3 相对线程安全

相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单词的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，但是**对于一些特定的顺序的连续调用**，就需要**在调用端使用额外的同步手段来保证调用的正确性**。

在 Java 语言中，大部分声称线程安全的类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection 方法包装的集合。

```java
public class VectorTest {
    
    private static final Vector<String> vector = new Vector<>();
    
    public static void main(String[] args) {
        
        Thread addThread = new Thread(new Runnable() {
            @Override
            public void run() {
                // 手动给vector加锁
                synchronized (vector) {
                    for (int i = 0; i < 100; i++) {
                        vector.add(String.valueOf(i));
                    }
                }
            }
        });

        Thread printThread = new Thread(new Runnable() {
            @Override
            public void run() {
                // 手动给vector加锁
                synchronized (vector) {
                    for (int i = 0; i < 100; i++) {
                        System.out.println(vector.get(i));
                    }
                }
            }
        });
        addThread.start();
        printThread.start();
    }
}
```



#### 2.1.4 线程兼容

线程兼容是指对象**本身并不是线程安全**的，但是可以通过**在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用**，比如说 ArrayList 和 HashMap 等。



#### 2.1.5 线程对立

线程对立是指不管调用端是否采用了同步措施，都无法在多线程环境中并发使用代码。由于 Java 语言天生就支持多线程的特性，线程对立这种排斥多线程的代码是很少出现的，而且是通常都是有害的，应当尽量避免。



### 2.2 线程安全的实现方法

在本节中，如何编写代码实现线程安全，以及虚拟机如何实现同步与锁这两方面都会设涉及。



#### 2.2.1 互斥同步

**互斥同步**是一种最常见也是最主要的**并发正确性保障手段**。**同步**是指**在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用**。而**互斥是实现同步的一种手段**，**临界区**、**互斥量**和**信号量**都是常见的互斥实现方式。在 "同步互斥" 这四个字里面，互斥是因，同步是果；互斥是方法，同步是目的。



在 Java 里面，最基本的互斥同步手段就是 **synchronized** 关键字，这是一种块结构的同步语法。synchronized 关键字经过 javac 编译之后，会在同步块前后分别形成 **monitorenter** 和 **monitorexit** 这两个字节码指令。这两个字节码指令都需要一个 **reference** 类型的参数来**指明要锁定和解锁的对象**。

在执行 monitorenter 指令时，首先要去尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一，而在执行 monitorexit 指令时会将锁计数器的值减一。一旦计数器的值为零，锁随即就被释放了。如果获取对象锁失败，那当前线程就应该被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。

- synchronized 是支持**可重入**的；
- synchronized 修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程地进入；



在 JDK5 起，Java 类库中提供了 `java.util.concurrent` 包，其中的 `java.util.concurrent.locks.Lock` 接口便成了 Java 另一种全新的互斥同步手段。基于 **Lock 接口**，用户能够以非块结构来实现互斥同步。

**重入锁（ReentrantLock）**是 Lock 接口最常见的一种实现，它与 synchronized 一样是可重入的。ReentrantLock 于 synchronized 相比增加了一些高级功能，主要有以下三项：**等待可中断**，**可实现公平锁**以及**锁可以绑定多个条件**。

- **等待可中断**：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助；
- **公平锁**：是指多个线程同时等待同一个锁时，必须按照申请锁的时间顺序来依次获取锁；而非公平锁不保证这一点，任何一个等待锁的线程都有机会获得锁；

- **锁绑定多个条件**：是指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，只需要多次调用 newCondition() 方法即可；



ReentrantLock 在功能上是 synchronized 的超集，在性能上又至少不会弱于 synchronized，但仍然推荐在 synchronized 与 ReentrantLock 都可满足需要时优先使用 synchronized：

- synchronized 是在 Java 语法层面的同步，足够清晰简单；
- Lock 应该确保在 finally 块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放锁；
- 从长远来看，Java 虚拟机更容易针对 synchronized 进行优化，因为 Java 虚拟机可以在线程和对象的元数据中记录 synchronized 中锁的相关信息，而使用 J.U.C 中的 Lock 的话，Java 虚拟机是很难得知具体哪些锁对象是由特定线程锁持有的；



#### 2.2.2 非阻塞同步

互斥同步面临的主要问题是**线程的阻塞**和**唤醒**所带来的性能开销，因此这种同步也称为**阻塞同步**。从解决问题的方式上看，互斥同步属于一种**悲观的并发处理**，其总是认为只要不去做正确的同步措施，那就肯定会出现问题，无论共享的数据是否真的会出现竞争，它都会进行加锁，这将会导致**用户态和内核态转换**、**维护锁计数器**和**检查是否有被阻塞的线程**需要被唤醒等开销。



随着指令集的发展，我们有了另一个选择：**基于冲突检测的乐观并发策略**，通俗的说，就是**不管风险，先进行操作**，如果没有其他线程争用共享数据，那操作直接成功。如果共享的数据的确被争用，产生了冲突，那就再进行其他的补偿措施，最常用的补偿措施就是不断地重试，直到没有竞争的共享数据为止。这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为非阻塞同步，这种措施的代码也常被称为无锁（Free Lock）编程；

乐观并发策略需要**操作和冲突检测两个步骤具备原子性**，我们只能靠硬件来实现这件事情，只通过一条处理器指令就可以完成：

- 测试并设置（Test-and-set）
- 获取并增加（Fetch-and-Increment）
- 交换（Swap）
- **比较并交换**（Compare-and-Swap，下文称 CAS）
- 加载链接/条件存储（Load-Linked/Store-Conditional，下文称 LL/SC）



CAS 指令有三个操作数，分别是**内存位置**（变量的内存地址，用 **V** 表示），**旧的预期值**（用 **A** 表示）和**准备设置的新值**（用 **B** 表示）。CAS 指令执行时，当且仅当 V 符合 A 时，处理器才会用 B 更新 V 的值，否则就不执行更新。但是，不管是否更新了 V 的值，**都会返回 V 的旧值**，上述过程是一个原子操作。

```java
/**
* Atomically increment by one the current value.
* @return the updated value
*/
public final int incrementAndGet() {
    for (;;) {
        int current = get();  // A
        int next = current + 1;
        if (compareAndSet(current, next)) // A与B
            return next;
    }
}
```



#### 2.2.3 无同步方案

要保证线程安全，也并非一定要进行阻塞或非阻塞同步，同步与线程安全两者没有必然的联系。同步只是保证存在共享数据争用时正确性的手段，如果能让一个方法本来就**不涉及共享数据**，那它自然就不需要任何同步措施去保证其正确性，因此有些代码天生就是线程安全的。



## 三、锁优化

高效并发是从 JDK5 升级到 JDK6 后一项重要的改进项，HotSpot 虚拟机开发团队花了大量资源去实现各种锁优化技术，如**适应性自旋**、**锁消除**、**锁膨胀**、**轻量级锁**、**偏向锁**等，这些技术都是为了在线程之间更高效地共享数据及解决竞争问题。



### 3.1 自旋锁与自适应自旋



#### 3.1.1 自旋锁

前面我们讨论互斥同步的时候，提到了互斥同步对性能最大的影响是**阻塞的实现**，**挂起线程**和**恢复线程**的操作都需要**转入内核态中完成**，这些操作给Java虚拟机的并发性能带来了很大的压力。虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态**只会持续很短的一段时间**，为了这段时间去挂起和恢复线程并不值得。

如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们就可以**让后面请求锁的那个线程"稍等一会"，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁**。为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是所谓的**自旋锁**。

自旋锁在JDK 1.4.2中就已经引入，只不过默认是关闭的，可以使用 `-XX:+UseSpinning` 参数来开启，在JDK 6中就已经改为默认开启了。

自旋是不能代替阻塞的，自旋本身虽然避免的线程切换的开销，但它要**占用处理器时间**，所以如果锁被占用的**时间很短**，自**旋等待的效果就特别好**，反之，如果等待的时间特别长，那么自旋就会白白消耗处理器资源，而不会做任何有价值的事情，带来性能的损耗。因此自旋等待的时间必须有一定限度，如果超过了这个限度还没有获取到锁，就应当使用传统的方式去挂起线程。**自旋的次数默认是 10 次**，用户可以使用参数 `-XX:PreBlockSpin` 来修改自旋的次数。



#### 3.1.2 自适应自旋

不过无论是默认值还是用户指定的自旋次数，对整个Java虚拟机中所有的锁来说都是相同的。在 JDK 6中对**自旋锁的优化**，引入了**自适应的自旋**。自适应意味着**自旋的时间不再是固定**的了，而是由**前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定**的。

如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。



### 3.2 锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是**对被检测到不可能存在共享数据竞争的锁进行消除**。锁消除主要判定依据是来源于逃逸分析的数据支持。如果判断到一段代码中，**在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待**，认为它们是**线程私有的**，同步加锁自然就无须再进行。



### 3.3 锁粗化

我们在编写代码时，总是推荐将同步块作用范围限制得尽量小 —— 只在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁。

大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都**对同一个对象反复加锁和解锁**，甚至**加锁操作是出现在循环体之中**的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

```java
StringBuffer stringBuffer = new StringBuffer();
stringBuffer.append("");
stringBuffer.append("");
stringBuffer.append("");

stringBuffer.toString();
```

- 如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，以上述代码为例，就是**扩展**到第一个`append()`操作之前直至最后一个`append()`操作之后，这样只需**要加锁一次**就可以了。



### 3.4 轻量级锁

轻量级锁是 JDK 6 时加入的新型锁机制，它名字中的 "轻量级" 是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就被称为 "重量级" 锁。

要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须要对 HotSpot 虚拟机对象的内存布局（尤其是对象头部分）有所了解。HotSpot 虚拟机的**对象头分为两部分**，**第一部分用于存储对象自身的运行时数据**，如**哈希码**（HashCode）、**GC 分代年龄**等。这部分数据会在 32 位和 64 位 的 Java 虚拟机中分别占用 32 个或者 64 个比特，官方称它为 **Mark Word**，这部分是实现**轻量级锁**和**偏向锁**的关键。 另一部分是用于**存储指向方法区对象类型的指针**，如果是数组对象，还会有一个额外的部分用于存储数组长度。



由于对象头信息是与**对象自身定义的数据无关的额外存储成本**，考虑到 Java 虚拟机的空间使用效率，Mark Word 被设计成一个**非固定的动态数据结构**，**以便在极小的空间内存储尽量多的信息**。它会根据对象状态复用自己的存储空间。

![虚拟机对象头的MarkWord](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240213002423076.png)



现在介绍轻量级锁的工作流程：

在代码进入同步块的时候，如果**此同步对象没有被锁定**（锁标志位为 "01" 状态），虚拟机首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象**目前**的 Mark Word 的**拷贝**（官方为这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word）

![轻量级锁CAS操作之前堆栈与对象的状态](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240213154519839.png)

然后，虚拟机将使用 **CAS 操作** 尝试**把对象的 Mark Word 更新为指向 Lock Record 的指针**。如果这个操作**成功**了，**即代表该线程拥有了这个对象的锁**，并且对象 Mark Word 的锁标志位（Mark Word 的最后两比特）将转变为 "00"，表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如下图：

![轻量级锁CAS操作之后堆栈与对象的状态](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240213160638793.png)



如果更新操作失败了，那就意味着**至少存在一条线程与当前线程竞争获取该对象的锁**。虚拟机首先会检查**对象的 Mark Word 是否指向当前线程的栈帧**，**如果是**，说明当前**线程已经拥有了这个对象的锁**，**那直接进入同步块继续执行就**可以了，**否则就说明这个锁对象已经被其他线程抢占了**。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要**膨胀为重量级锁**，**锁标志的状态值变为 "10"**，此时 Mark Word 中存储的就是指向重量级锁的指针，后面等待锁的线程也必须进入阻塞状态。



上面**描述的是轻量级锁的加锁过程**，它的解锁过程也同样是通过 CAS 操作来进行的，如果**对象的 Mark Word 仍然指向线程的锁记录**，那就用 **CAS 操作**把对象**当前的 Mark Word** 和**线程中复制的 Displaced Mark Word** 替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试获取该锁，就要在释放锁的同时，唤醒被挂起的线程。

**轻量级锁能提升程序同步性能**的依据是 "**对于绝大部分的锁，在整个同步周期内都是不存在竞争**" 这一经验法则。如果没有竞争，轻量级锁便通过 CAS 操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了 CAS 操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。



### 3.5 偏向锁

**偏向锁**也是 JDK 6 中引入的一项锁的优化措施，它的目的是消除数据无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那**偏向锁就是在无竞争的情况下把整个同步都消除掉**，连 **CAS 操作都不去做了**。



当锁对象第一次被线程获取的时候，虚拟机将会把**对象头中的标志位设置为 "01"**、**把偏向模式设置为 "1"**，表示**进入偏向模式**。同时使用 CAS 操作**把获取到这个锁的线程的 ID 记录在 Mark Word 之中**。如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对 Mark Word 的更新操作等）

**一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束**。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为 "0"），撤销后标志位恢复到未锁定（标志位为 "01"）或轻量级锁定（标志位为 "00"）的状态，后续的同步操作就按照上面介绍的**轻量级锁**那样去执行。



偏向锁、轻量级锁的状态转化及对象 Mark Word 的关系如下图所示：

![偏向锁、轻量级锁的状态转化及对象Mark Word的关系](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240213224256508.png)



当对象进入偏向状态的时候， Mark Word 大部分的空间（23个比特）都用于存储持有锁的线程 ID 了，这部分空间占用了原有存储对象哈希码的位置，那原来对象的哈希码怎么办（记录哈希码的位置消失了，所以偏向锁和哈希码的计算只能存在一种情况）？

在Java语言里面一个对象如果计算过哈希码，就应该一直保持该值不变（强烈推荐但不强制，因为用户可以重载hashCode()方法按自己的意愿返回哈希码），否则很多依赖对象哈希码的API都可能存在出错风险。而作为绝大多数对象哈希码来源的Object::hashCode()方法，返回的是对象的一致性哈希码（Identity Hash Code），这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。因此，当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了；而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。
