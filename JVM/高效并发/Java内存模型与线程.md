# Java 内存模型与线程



## 一、背景

并发处理的广泛应用是人类压榨计算机运算能力的最有力的武器。在许多场景下，让计算机同时去做几件事情，是因为计算机的运算速度与它的存储和通信子系统的速度差距太大，大量的时间都花费在磁盘 I/O、网络通信或者数据库访问上。



## 二、硬件的效率与一致性

现代计算机加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲，但是为计算机系统带来了更高的复杂度，它引入了一个新的问题：缓存一致性。在多路处理器系统中，每个处理器都有自己的**高速缓存**，而它们又**共享同一主内存**，这种系统称为**共享内存多核系统**。

当多个处理器任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。

![共享内存多核系统](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240210102430540.png)



除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，即**指令重排序**。



## 三、Java 内存模型



### 3.1 主内存与工作内存

Java 内存模型的主要目的是**定义程序中各种变量的访问规则**，即关注在虚拟机中变量值**存储到内存**和**从内存取出变量**这样的底层细节。

**Java 内存模型规定**了所有的变量都存储在**主内存**中（可以类比物理硬件的主内存），每条线程还有自己的**工作内存**，线程的工作内存中保存了被该线程使用的**变量的主内存副本**。线程对变量的所有操作都必须在**工作内存中进行**，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对工作内存中的变量，线程间的变量值的传递均需要通过主内存来完成。

![工作内存与主内存](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240210122837071.png)

### 3.2 内存间交互操作

关于主内存与工作内存之间的具体协议，即一个变量如何**从主内存拷贝到工作内存**、如何**从工作内存同步回主内存**这一类的实现细节，Java 内存模型中定义了以下 8 种操作来完成（Java 虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的）

- **lock**（锁定）：作用于主内存的变量，它把一个变量标识位一个线程独占的状态；
- **unlock**（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；
- **read**（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用；
- **load**（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中；
- **use**（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行这个操作
- **assign**（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作；
- **store**（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存，以便随后的 write 操作使用；
- **write**（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量值放入主内存的变量中；



如果要把一个变量从主内存拷贝到工作内存，就要执行 read 和 load 指令，如果要把一个变量从工作内存拷贝到主内存，就要执行 store 和 write 指令。Java 内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行，也就是说 read 与 load  之间，store 与 write 之间是可插入其他指令的，如对主内存中的变量 a、b进行访问，一种可能出现的顺序是 read a、read b、load b、load a



执行上述八条指令时，还需要满足以下规则：

- 不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现；
- 不允许一个线程丢弃它最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存；
- 不允许一个线程无原因（没发生过任何 assign 操作）地把数据从线程的工作内存同步回主内存；

- 在对一个变量实施 use、store 操作之前，必须先执行 assign 和 load 操作；



### 3.3 对于 volatile 变量的特殊规则

当一个变量被定义为 volatile 之后，它将具备两项特性：

- **可见性**：当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。

> 由于 volatile 只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性：
>
> 1. 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值；
> 2. 变量不需要与其他的状态变量共同参与不变约束；

- **有序性**：禁止指令重排序优化

> 普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中执行的一致。



指令重排序代码演示：

**读取配置信息**

```jav
Map configOptions;
char[] configText;
volatile boolean inited = false;

// 假设以下代码在线程A中执行
// 模拟读取配置信息，当读取完成后，将inited=true，通知其他线程可用
configOptions = new HashMap();
configText = readConfigFile();
inited = true;

// 假设以下代码在线程B中执行，代表线程A已经把配置信息
while(!inited) {
	sleep();
}
doSomething();
```

- 如果 `inited` 变量没有被 volatile 修饰，就可能会由于指令重排序的优化，导致位于线程 A 中最后一条代码 `initialized = true` 被提前执行，这样在线程 B 中使用配置信息的代码就可能出现错误。



**DCL 单例模式**

```java
public class Singleton {
    
    private volatile static Singleton instance;
    
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }       
        return instance;
    }
}
```



将代码转化为汇编代码

![volatile汇编代码](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240210174205609.png)

- 在有 volatile 变量修饰的变量，赋值后（`mov $0x3375cdb0,%esi`便是赋值语句）多执行了一个 "lock addl $0x0,(%esp)" 操作，这个操作相当于一个内存屏障（值重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个处理器访问内存时，并不需要内存屏障；但是如果有两个或更多处理器访问同一块内存，且其中有一个在观察另一个，就需要内存屏障来保证一致性了。

- `lock addl $0x0,(%esp)` （把 ESP 寄存器的值加 0）显然是一个空操作，之所以用这个空操作而不是空操作专用指令 nop，是因为 IA32 手册规定 lock 前缀不允许配合 nop 指令使用；
- **lock 前缀**的作用是**将本处理器的缓存写入了内存**，该写入动作也会**引起别的处理器或者别的内核无效化其缓存**，这种操作相当于对缓存中的变量做了一次前面介绍 Java 内存模型中的 **store** 和 **write** 操作。所以通过这样一个空操作，**可让前面 volatile 变量的修改对其他处理器立即可见**。

那为何说它禁止指令重排序呢？从硬件架构上讲，指令重排序是指处理器采用了允许将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理。但并不是说指令任意重排，处理器必须能正确处理指令依赖情况保障程序能得出正确的执行结果。譬如指令1把地址A中的值加10，指令2把地址A中的值乘以2，指令3把地址B中的值减去3，这时指令1和指令2是有依赖的，它们之间的顺序不能重排一`(A+10)*2`与 `A*2+10`显然不相等，但指令3可以重排到指令1、2之前或者中间，**只要保证处理器执行后面依赖到 A、B 值的操作时能获取正确的A和B值即可**。所以在同一个处理器中，重排序过的代码看起来依然是有序的。因此，`lock addls$Ox0,(%esp)`指令把修改同步到内存时，意味着所有**之前的操作都已经执行完成**，这样便形成了 “**指令重排序无法越过内存屏障**” 的效果。



### 3.4 针对 long 和 double 型变量的特殊规则

Java 内存模型要求 lock、unlock、read、load、assign、use、store、write 这八种操作都具有原子性，但是对于 64 位的数据类型（long 和 double），在模型中特别定义了一条宽松的规定：**允许虚拟机将没有 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行**，即允许虚拟机实现自行选择是否要保证 64 位数据类型的 load、store、read 和 write 这四个操作的原子性。

如果有多个线程共享一个并未声明为 volatile 的 long 或 double 类型的变量，并且同时它们进行读取和修改操作，那么某些线程可能会读取到一个既不是原值，也不是其他线程修改值的代表了 "半个变量" 的数值。



### 3.5 原子性、可见性与有序性

#### 3.5.1 原子性

由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write 这六个，我们大致可以认为，基本数据类型的访问、读写都是具备原子性的。

如果一个应用场景需要一个更大范围的原子性保证，Java 内存模型还提供了 lock 和 unlock 操作来满足这种需求，尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 **monitorenter** 和 **monitorexit** 来隐式使用这两个操作，这两个字节码指令反应到 Java 就是同步块 —— **synchronized** 。



#### 3.5.2 可见性

可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的。**volatile 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新**。

除了 volatile 之外，Java 还有两个关键字可以实现**可见性**，它们是 **synchronized** 和 **final**。同步块的可见性是由 "**对一个变量执行 unlock 操作之前，必须先把它们同步回主内存中（执行 store、write 操作）**" 这条规则获得的。而 final 关键字的可见性是指：被 final 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把 this 的引用传递出去，那么在其他线程中就能看到 final 字段的值。



#### 3.5.3 有序性

Java 程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有操作都是有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指 "线程内似表现为串行的语义"，后半句是指 "指令重排序" 现象和 "工作内存与主内存同步延迟" 现象。

Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，**volatile 本身就包含了禁止指令重排序的语义**，而 synchronized 则是由 "**一个变量在同一时刻只允许一条线程对其进行 lock 操作**" 这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。



### 3.6 现行发生原则

Java 语言中有一个**先行发生原则（Happens-before）**，它是判断数据**是否存在竞争**，**线程是否安全**的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决**并发环境下两个操作之间**是否可能存在冲突的所有问题，而不需要陷入 Java 内存模型苦涩难懂的定义之中。

先行发生是 **Java 内存模型中定义的两项操作之间的偏序关系**，比如说操作 A 先行于操作 B，其实就是说在发送操作 B 之前，操作 A 产生的影响能被操作 B 观察到，"影响" 包括修改了内存中共享变量的值、发送了消息、调用了方法等。



下面是 Java 内存模型下一些天然的先行发生关系，这些先行发生关系无需任何同步器协助就已经存在，可以在编码中直接使用：

- **程序次序规则**：在一个线程内，按照控制流顺序，**书写在前面的操作先行于书写在后面的操作**；
- **管程锁定规则**：一个 unlock 操作先行发生于后面对**同一个锁**的 lock 操作；

- **volatile 变量规则**：对一个 **volatile** 变量的**写操作先行发生于后面对这个变量的读操作**；

- **线程启动规则**：Thread 对象的 **start 方法**先行发生于此线程的每一个动作；

- **线程终止规则**：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 `Thread::join` 方法检测线程是否结束，`Thread::isAlive` 的返回值等手段检测线程是否已经终止；
- **线程中断规则**：对线程 interrupt 方法的调用先行发生于**被中断线程的代码检测到中断事件的发生**，可以通过 Thread::interrupter 方法检测是否有中断发生；
- **对象终结规则**：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize 方法的开始；

- **传递性**：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论；



Java 语言无须任何同步手段保障就能成立的先行发生规则有且只有上面这些，下面举个例子：

```java
private int value = 1;

public int getValue() {
    return value;
}

public void setValue(int value) {
    this.value = value;
}
```

假设线程 A 和 B，线程 A 先调用 setValue(1)，线程 B 调用了同一个对象的 getValue()，那么 B 收到的返回值是什么？

根据以上先行发生规则分析：由于两个方法分别由线程 A 和 B 调用，不在同一个线程中，所以**程序次序规则在这里不适用**；由于没有同步块，自然就不会发生 lock 和 unlock 操作，所以**管程锁定规则不适用**；由于变量 value 没有被 volatile 修饰，所以 v**olatile 变量规则也不适用**；后面的线程启动、终止、中断规则和对象终结规则也和这里没有关系。因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起，所以我们可以判定，这里的操作不是线程安全的。

如何修复这个问题：

1. 把 getter/setter 方法都定义为 synchronized 方法；
2. 把 value 定义为 volatile 变量，由于 setter 方法对 value 的修改不依赖 value 的原值，满足 volatile 关键字的使用场景，这样就可以套用 volatile 变量规则来实现先行发生关系；



## 四、Java 与线程

并发不一定要依赖多线程，但是 Java 里面谈论并发，基本上都和线程脱不开关系；

### 4.1 线程的实现

实现线程的方式有三种：**使用内核线程实现**（1:1 实现），**使用用户线程实现**（1:N 实现），**使用用户线程加轻量级进程混合实现**（N:M 实现）



#### 4.1.1 内核线程实现

使用内核线程实现的方式也被称为1：1实现。内核线程（Kernel-Level Thread，KLT）就是直接由**操作系统内核**（Kernel，下称内核）**支持的线程**，**这种线程由内核来完成线程切换**，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核（Multi-Threads Kernel）。

程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程（Light Weight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，**由于每个轻量级进程都由一个内核线程支持**，因此**只有先支持内核线程，才能有轻量级进程**。这种轻量级进程与内核线程之间1：1的关系称为一对一的线程模型。

轻量级进程也具有它的局限性：首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。



#### 4.1.2 用户线程实现

使用用户线程实现的方式被称为1：N实现。广义上来讲，一个线程只要不是内核线程，都可以认为是用户线程（User Thread，UT）的一种，因此从这个定义上看，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，因此效率会受到限制，并不具备通常意义上的用户线程的优点。



而狭义上的**用户线程指的是完全建立在用户空间的线程库上**，系统内核不能感知到用户线程的存在及如何实现的。用户线程的**建立**、同**步**、**销毁**和**调度**完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程**不需要切换到内核态**，因此操作可以是非常快速且低消耗的，也能够支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间1：N的关系称为一对多的线程模型。



#### 4.1.3 混合实现

线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式，被称为N：M实现。在这种混合实现下，**既存在用户线程，也存在轻量级进程**。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而**操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁**，这样可以使用**内核提供的线程调度功能及处理器映射**，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，是N：M的关系，这种就是多对多的线程模型。



####  4.1.4 Java 线程的实现

从JDK 1.3起，“主流”平台上的 "主流” 商用Java虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现，即采用1：1的线程模型。

以HotSpot为例，它的每一个Java线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构，所以HotSpot自己是不会去干涉线程调度的（可以设置线程优先级给操作系统提供调度建议），全权交给底下的操作系统去处理，所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，都是由操作系统完成的，也都是由操作系统全权决定的。

### 4.2 Java 线程调度

线程调度是指**系统为线程分配处理器使用权的过程**，调度主要方式有两种，分别是**协同式**（Cooperative Threads-Scheduling）线程调度和**抢占式**（Preemptive Threads-Scheduling）线程调度。



### 4.3 Java 状态转换

Java 中定义了 6 种线程状态，在任意一个时间点，一个线程只能有且只有其中其中的一种状态，并且可以通过特定的方法在不同状态之间进行转换。

**新建（New）**：创建后尚未启动的线程；

**运行（Runnable）**：包括操作系统线程中的 ready 和 running，也就是处于该状态的线程可能正在执行，也可能正在等待操作系统分配为它分配时间；

**无限期等待（Waiting）**：处于这种状态的线程不会被分配处理器时间，它们要等待被其他线程显示唤醒，以下是会让线程陷入无限期等待的状态：

- 没有设置 timeout 的 Object::wait() 方法；
- 没有设置 timeout 的 Thread::join() 方法；
- LockSupport::park() 方法；

**限期等待（Timed Waitng）**：处于这种状态的线程也不会分配处理器时间，不过无需无限期等待其他线程显示唤醒，在一定时间之后它们会由系统自动唤醒；

- Thread::sleep() 方法；
- 设置了 timeout 的 Object::wait() 方法；
- 设置了 timeout 的 Thread::join() 方法；
- LockSupport::parkNanos() 方法；
- LockSupport::partUntil() 方法；

**阻塞（Blocked）**：线程被阻塞了，"阻塞状态" 在等待着获取一个排它锁，这个事件将在另一个线程放弃这个锁的时候发生。在程序等待进入同步区域时，线程将进入这种状态；

**结束（Terminated）**：已终止线程的线程状态，线程已经结束执行；



![线程状态转换](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240212134745486.png)

## 五、Java 与协程



### 5.1 内核线程的局限

Java 并发编程机制的矛盾：1：1的内核线程模型是如今Java虚拟机线程实现的主流选择，但是这种映射到操作系统上的线程天然的缺陷是**切换、调度成本高昂**，系统能容纳的**线程数量也很有限**。以前处理一个请求可以允许花费很长时间在单体应用中，具有这种线程切换的成本也是无伤大雅的，但现在在**每个请求本身的执行时间变得很短、数量变得很多的前提下**，**用户线程切换的开销甚至可能会接近用于计算本身的开销**，这就会造成严重的浪费。



### 5.2 协程的复苏

为什么内核线程调度切换起来成本更高？

内核线程的调度成本主要来自于用户态和内核态之间的状态切换，而这两种状态转换的开销主要来自于**响应中断**、**保护**和**恢复执行现场**的成本。

当中断发生，从线程A切换到线程B去执行之前，操作系统**首先要把线程A的上下文数据妥善保管**好，然后把**寄存器**、**内存分页**等**恢复到线程B挂起时候的状态**，这样线程B被重新激活后才能仿佛从来没有被挂起过。这种保护和恢复现场的工作，免不了涉及一系列数据在各种寄存器、缓存中的来回拷贝，当然不可能是一种轻量级的操作。

如果说内核线程的切换开销是来自于保护和恢复现场的成本，那如果改为采用用户线程，这部分开销就能够省略掉吗？答案是“不能”。但是，**一旦把保护、恢复现场及调度的工作从操作系统交到程序员手上**，那我们就可以打开脑洞，通过玩出很多新的花样来缩减这些开销。

到后来，操作系统开始提供多线程的支持，靠应用自己模拟多线程的做法自然是变少了许多，但也并没有完全消失，而是**演化为用户线程继续存在**。由于最初多数的**用户线程**是被设计成**协同式调度**（Cooperative Scheduling）的，所以它有了一个别名——“协程”（Coroutine）。
